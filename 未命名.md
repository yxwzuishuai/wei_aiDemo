以下是库存扣减面试题的详细参考答案，结合Java后端技术栈（Spring Boot、分布式、高并发），兼顾原理、实现方案与实战经验，逻辑清晰且贴合面试场景：

### 一、基础概念与核心问题（初级/中级）
#### 1. 库存扣减业务中最核心的问题是什么？如何避免「超卖」？请列举至少2种实现方案，并说明各自的优缺点。
**核心问题**：并发场景下的「数据一致性」，即避免超卖（库存为负）、少卖（库存未扣减但订单已创建），同时兼顾性能。

**避免超卖的核心方案**：
| 方案 | 实现逻辑 | 优点 | 缺点 |
|------|----------|------|------|
| 数据库原子更新（WHERE条件控制） | 直接执行 `UPDATE product_stock SET available_stock = available_stock - #{num} WHERE product_id = #{id} AND available_stock >= #{num}` | 1. 无需额外组件，实现简单；2. 数据库层面保证原子性，无超卖风险；3. 适合中低并发场景 | 1. 高并发下数据库压力大（所有请求穿透到DB）；2. 无缓存隔离，响应速度受限 |
| 乐观锁（Version版本号） | 库存表加`version`字段，更新时带版本号：`UPDATE ... WHERE product_id = #{id} AND version = #{version} AND available_stock >= #{num}`，更新成功则version+1 | 1. 无锁竞争，高并发下性能优于悲观锁；2. 支持高并发读场景 | 1. 冲突频繁时（如秒杀），重试次数多，用户体验差；2. 需要处理重试逻辑（如循环重试或返回失败） |
| 悲观锁（数据库行锁） | 用`SELECT ... FOR UPDATE`查询库存并加行锁，再执行扣减：`BEGIN; SELECT available_stock FROM product_stock WHERE product_id = #{id} FOR UPDATE; UPDATE ...; COMMIT;` | 1. 强一致性，适合写多读少场景；2. 逻辑直观，无需重试 | 1. 锁竞争严重，高并发下会导致线程阻塞，性能差；2. 可能出现死锁风险（需控制事务时长） |

#### 2. 为什么直接使用「先查询库存（SELECT）再扣减（UPDATE）」的逻辑会导致超卖？请从并发原理层面解释。
**本质原因**：「查询-扣减」是两步操作，非原子性，存在并发竞争导致的「race condition」（竞态条件）。

**原理分析**：
- 高并发下，多个线程同时执行`SELECT available_stock FROM product_stock WHERE product_id = 1`，假设查询结果均为10。
- 线程A执行`UPDATE ... SET available_stock = 10 - 1 = 9`，线程B同时执行`UPDATE ... SET available_stock = 10 - 1 = 9`。
- 最终库存扣减2次，但实际只减少了1，导致「少扣减」；若初始库存为1，两个线程同时查询到1，都执行扣减，则库存变为-1，导致「超卖」。
- 核心问题：两步操作之间无锁保护，中间状态可被其他线程修改，破坏了数据一致性。

#### 3. 数据库层面如何通过SQL实现原子性的库存扣减？请写出核心SQL，并说明WHERE条件的作用。
**核心SQL**：
```sql
UPDATE product_stock
SET available_stock = available_stock - #{quantity},
    update_time = NOW()
WHERE product_id = #{productId} 
  AND available_stock >= #{quantity}; -- 关键条件：保证库存充足
```

**WHERE条件的作用**：
1. **原子性保证**：UPDATE语句是数据库层面的原子操作，同一时间只有一个事务能修改该记录（InnoDB行锁），避免并发冲突。
2. **防超卖**：`available_stock >= #{quantity}` 确保只有库存充足时才执行扣减，库存不足则更新行数为0，直接返回失败。
3. **无需额外锁**：无需手动加悲观锁，依赖数据库行锁和SQL原子性，简化逻辑。

#### 4. 乐观锁和悲观锁在库存扣减场景中如何应用？分别适用于什么业务场景（高并发/低并发）？
**乐观锁应用**：
- 实现方式：库存表加`version`字段，更新时携带版本号，更新成功则版本号自增。
  ```sql
  UPDATE product_stock
  SET available_stock = available_stock - #{quantity},
      version = version + 1
  WHERE product_id = #{productId} 
    AND available_stock >= #{quantity}
    AND version = #{version}; -- 版本号匹配才更新
  ```
- 业务场景：**高并发读多写少**（如普通商品库存扣减，并发请求多但实际扣减频率低），优点是无锁竞争，性能高；缺点是冲突时需重试。

**悲观锁应用**：
- 实现方式：通过`SELECT ... FOR UPDATE`加行锁，确保事务期间其他线程无法修改该记录。
  ```sql
  BEGIN; -- 开启事务
  -- 查询并加行锁（InnoDB默认行锁，需索引命中）
  SELECT available_stock FROM product_stock WHERE product_id = #{productId} FOR UPDATE;
  -- 扣减库存（此时库存已被锁定，其他线程需等待）
  UPDATE product_stock SET available_stock = available_stock - #{quantity} WHERE product_id = #{productId};
  COMMIT; -- 提交事务，释放锁
  ```
- 业务场景：**低并发写多读少**（如高端商品限量发售，并发请求少但需强一致性），优点是逻辑简单，无重试；缺点是锁竞争导致阻塞，高并发下性能差。

#### 5. 库存扣减时，除了「可用库存」，是否需要设计「锁定库存」字段？请说明使用场景（如订单未支付时的库存占用）。
**需要设计「锁定库存」字段**，核心用于「库存占用-确认扣减-释放库存」的完整流程，避免超卖同时提升用户体验。

**核心场景**：订单创建后未支付（如电商下单后15分钟未支付自动取消）。
- 流程设计：
  1. 用户下单时，先将「可用库存」转为「锁定库存」：`UPDATE product_stock SET available_stock = available_stock - #{num}, locked_stock = locked_stock + #{num} WHERE product_id = #{id} AND available_stock >= #{num}`。
  2. 用户支付成功：将「锁定库存」扣减（确认扣减）：`UPDATE product_stock SET locked_stock = locked_stock - #{num} WHERE product_id = #{id}`。
  3. 用户未支付/取消订单：释放「锁定库存」回「可用库存」：`UPDATE product_stock SET available_stock = available_stock + #{num}, locked_stock = locked_stock - #{num} WHERE product_id = #{id}`。
- 核心价值：避免订单未支付时库存被其他用户占用，同时防止用户支付后无库存，平衡「可用性」和「一致性」。

### 二、分布式与高并发场景（中级/高级）
#### 1. 分布式部署（多节点）下，库存扣减如何保证并发安全？分布式锁的实现方案有哪些（Redis/ZooKeeper/数据库）？各自的优缺点是什么？
**分布式并发安全核心**：多节点共享同一库存数据，需通过「分布式锁」实现跨节点的互斥操作，确保同一商品的库存扣减同一时间只有一个节点执行。

**分布式锁实现方案对比**：
| 方案 | 实现逻辑 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| Redis分布式锁（Redisson） | 基于Redis的`SET NX EX`命令（原子操作），加锁时设置过期时间，Redisson提供看门狗机制自动续期 | 1. 性能高（Redis单机QPS万级）；2. 部署简单；3. 支持可重入、公平锁等特性 | 1.  Redis单点故障风险（需集群部署）；2. 主从切换时可能出现锁丢失（需红锁方案） | 高并发场景（如秒杀、电商库存） |
| ZooKeeper分布式锁 | 基于ZooKeeper的临时有序节点，客户端创建节点后，监听前序节点，前序节点删除则竞争锁 | 1. 强一致性（CP），无锁丢失风险；2. 支持公平锁；3. 崩溃自动释放锁 | 1. 性能低（ZooKeeper QPS千级）；2. 部署复杂（需集群） | 强一致性场景（如金融库存、支付） |
| 数据库分布式锁 | 基于数据库表（如`distributed_lock`），通过`INSERT`加锁（唯一索引保证互斥），`DELETE`释放锁 | 1. 实现简单（无需额外组件）；2. 无需担心第三方依赖 | 1. 性能差（数据库压力大）；2. 可能出现死锁（需设置过期时间）；3. 单点故障（需主从） | 低并发、小型系统 |

#### 2. Redisson分布式锁的「看门狗机制」是什么？在库存扣减场景中如何避免锁超时导致的超卖？
**看门狗机制**：Redisson的分布式锁默认开启看门狗（Watch Dog），当用户未指定锁的过期时间时，锁默认过期时间为30秒，Redisson会启动一个后台线程，每隔10秒（过期时间的1/3）自动为锁续期，确保锁在业务执行期间不失效。

**避免锁超时超卖的方案**：
1. **开启看门狗自动续期**：使用Redisson的`RLock`时，不指定过期时间（或通过`lock()`方法），看门狗会自动续期，直到业务执行完成释放锁。
   ```java
   RLock lock = redissonClient.getLock("lock:stock:" + productId);
   lock.lock(); // 无过期时间，看门狗自动续期
   try {
       // 库存扣减逻辑
   } finally {
       lock.unlock();
   }
   ```
2. **手动设置足够长的过期时间**：若明确业务执行时间（如库存扣减最多5秒），可设置过期时间为10秒，避免锁提前过期。
3. **业务超时控制**：在锁内执行业务时，设置超时时间（如通过`CompletableFuture`超时中断），避免业务执行过长导致锁续期失败。

#### 3. 高并发（QPS 1000+）场景下，如何减少数据库压力？Redis缓存库存时，需要注意哪些问题（缓存穿透/击穿/雪崩）？如何解决？
**减少数据库压力的核心方案**：
1. **Redis缓存前置**：将库存数据缓存到Redis，查询先查Redis，缓存命中则无需访问数据库（缓存命中率需达到99%以上）。
2. **缓存预热**：系统启动时，将热点商品库存批量加载到Redis，避免缓存穿透。
3. **异步同步缓存**：库存扣减后，通过消息队列（如RocketMQ）异步同步数据库数据到Redis，减少同步更新的性能损耗。
4. **限流熔断**：通过Sentinel限制单商品的并发扣减请求数，避免数据库被突发流量击垮。

**Redis缓存核心问题及解决方案**：
| 问题 | 定义 | 解决方案 |
|------|------|----------|
| 缓存穿透 | 恶意请求查询不存在的商品ID，缓存和数据库都无数据，导致请求直接穿透到数据库 | 1. 布隆过滤器过滤不存在的商品ID；2. 缓存空值（设置短期过期时间，如5分钟）；3. 接口层校验商品ID合法性 |
| 缓存击穿 | 热点商品的缓存过期，大量请求同时穿透到数据库，导致数据库压力突增 | 1. 缓存永不过期（通过后台线程定期更新）；2. 互斥锁（缓存过期时，只有一个线程查询数据库并更新缓存）；3. 预热热点商品缓存 |
| 缓存雪崩 | 大量缓存同时过期（如整点过期），或Redis集群宕机，导致所有请求穿透到数据库 | 1. 缓存过期时间随机化（如加1-5分钟随机值）；2. Redis集群部署（主从+哨兵）；3. 降级方案（缓存宕机时，直接返回库存不足，保护数据库） |

#### 4. 缓存与数据库的一致性如何保障？库存扣减时，是「先更数据库再更缓存」还是「先更缓存再更数据库」？请说明理由及可能的问题。
**缓存与数据库一致性核心原则**：高并发场景下，优先保证「最终一致性」，避免因强一致性导致性能瓶颈。

**两种更新策略对比**：
| 策略 | 流程 | 优点 | 可能的问题 | 解决方案 |
|------|------|------|------------|----------|
| 先更数据库，再更缓存 | 数据库扣减库存 → 缓存扣减库存 | 逻辑直观，数据库更新成功后同步缓存 | 1. 数据库更新成功，缓存更新失败 → 缓存脏数据；2. 高并发下，两次更新请求顺序颠倒（如线程A先更DB，线程B后更DB，线程B先更缓存，线程A后更缓存） → 缓存脏数据 | 1. 缓存更新失败重试（结合消息队列）；2. 采用「先删缓存再更数据库」+ 延迟双删 |
| 先更缓存，再更数据库 | 缓存扣减库存 → 数据库扣减库存 | 缓存更新快，能快速响应后续请求 | 1. 缓存更新成功，数据库更新失败 → 缓存脏数据（库存已扣减但DB未变）；2. 高并发下，缓存更新后DB未更新，其他线程查询缓存得到脏数据 | 几乎不推荐，仅适用于允许短暂不一致的场景（如非核心商品） |

**推荐策略：先删缓存再更数据库 + 延迟双删**：
1. 流程：删除缓存 → 数据库扣减库存 → 延迟1-3秒再次删除缓存。
2. 核心逻辑：
   - 第一次删除缓存：避免后续请求读取旧缓存。
   - 数据库更新：保证数据一致性。
   - 延迟双删：解决「数据库更新后，缓存被其他线程重新写入旧数据」的问题（如线程A删除缓存→线程B查询DB→线程A更新DB→线程B写入旧缓存，延迟双删可删除该旧缓存）。
3. 实现方式：延迟双删可通过`Thread.sleep()`（简单场景）或消息队列（高并发场景）实现。

#### 5. 库存扣减的「最终一致性」和「强一致性」如何选择？如果业务允许短暂的库存不一致（如秒杀后1分钟内同步），可以设计哪些方案？
**一致性选择原则**：根据业务场景的「一致性要求」和「性能要求」权衡：
- 强一致性：适用于金融、支付等核心场景（如库存扣减后必须立即反映到数据库，不允许任何不一致）。
- 最终一致性：适用于电商、秒杀等高并发场景（允许短暂不一致，但需在合理时间内同步）。

**最终一致性方案设计**：
1. **消息队列异步同步**：
   - 流程：库存扣减 → 发送消息到队列 → 消费者消费消息，同步缓存和数据库 → 失败重试。
   - 核心：通过消息队列的可靠性投递（如RocketMQ的事务消息）保证同步不丢失，最终实现数据一致。
2. **数据库binlog同步缓存**：
   - 流程：数据库扣减库存（生成binlog） → Canal监听binlog → 解析binlog并更新Redis缓存。
   - 核心：无需业务代码干预，通过中间件实现异步同步，性能高且一致性强。
3. **定时任务补偿**：
   - 流程：后台定时任务（如每分钟）查询数据库和缓存的库存差异 → 同步不一致的数据。
   - 核心：兜底方案，解决消息队列或binlog同步失败的问题，确保最终一致性。

### 三、架构设计与优化（高级/架构师）
#### 1. 设计一套支持「秒杀场景」的库存扣减系统（QPS 10000+，5个节点部署），请画出架构图，并说明核心组件（缓存、锁、数据库、消息队列）的作用。
**架构图（文字描述）**：
```
用户 → CDN → 负载均衡（Nginx） → 5个应用节点（Spring Boot） → 限流熔断（Sentinel） → 分布式锁（Redis Cluster）
                                                                 ↓
                                                            缓存层（Redis Cluster）
                                                                 ↓
                                                            消息队列（RocketMQ）
                                                                 ↓
                                                            数据库层（MySQL主从+分库分表）
```

**核心组件作用**：
1. **CDN**：缓存静态资源（如秒杀页面），减少应用节点压力。
2. **负载均衡（Nginx）**：将请求均匀分发到5个应用节点，实现负载分担。
3. **限流熔断（Sentinel）**：
   - 限流：限制单商品的并发请求数（如每秒10000次），避免超阈值请求压垮系统。
   - 熔断：当库存服务异常（如响应时间超过500ms），自动降级返回「活动火爆，请稍后重试」，保护核心流程。
4. **分布式锁（Redis Cluster）**：
   - 作用：实现跨节点的互斥操作，确保同一商品的库存扣减同一时间只有一个节点执行，避免超卖。
   - 配置：Redis Cluster集群（3主3从），Redisson客户端，开启看门狗机制。
5. **缓存层（Redis Cluster）**：
   - 作用：缓存热点商品库存，拦截99%以上的查询请求，减少数据库压力。
   - 优化：缓存预热（秒杀前加载库存）、缓存永不过期（后台线程定期更新）、防止缓存穿透/击穿/雪崩。
6. **消息队列（RocketMQ）**：
   - 削峰填谷：接收高并发的库存扣减请求，异步消费，避免数据库被突发流量击垮。
   - 异步同步：消费消息时同步数据库和缓存，实现最终一致性。
   - 库存回滚：订单取消时，通过消息队列触发库存释放。
7. **数据库层（MySQL主从+分库分表）**：
   - 主从复制：主库写入库存扣减，从库负责查询，分担读压力。
   - 分库分表：按商品ID哈希分片（如分8个库16个表），解决单库单表性能瓶颈。
   - 索引优化：`product_id`唯一索引，`available_stock`普通索引，提升更新和查询效率。

#### 2. 消息队列在库存扣减场景中能解决什么问题？如何通过消息队列实现「异步扣减」「库存回滚」（如订单取消后释放库存）？
**消息队列核心作用**：
1. **削峰填谷**：高并发场景下，请求先写入消息队列，避免直接冲击数据库，将瞬时高流量转为平稳流量。
2. **异步解耦**：库存扣减与订单创建、支付等流程解耦，库存服务只需关注自身逻辑，通过消息队列通信。
3. **可靠性保证**：支持消息重试、死信队列，确保库存扣减和回滚不丢失。
4. **最终一致性**：通过异步消费实现缓存与数据库的同步，保证数据最终一致。

**异步扣减实现**：
1. 流程：用户下单 → 订单服务发送「库存扣减消息」到RocketMQ → 库存服务消费消息 → 执行库存扣减（Redis+数据库） → 消费成功返回ACK，失败则重试（最多3次）。
2. 关键：消息队列设置 Topic 为`stock-deduct-topic`，库存服务作为消费者，通过集群部署提高消费能力，确保消息不堆积。

**库存回滚实现**：
1. 流程：用户取消订单 → 订单服务发送「库存回滚消息」到RocketMQ（设置延迟队列，如15分钟未支付自动触发） → 库存服务消费消息 → 执行库存释放（`available_stock += quantity`） → 同步缓存。
2. 关键：
   - 消息携带订单ID和商品ID、数量，确保回滚精准。
   - 死信队列：回滚失败的消息（如数据库异常）进入死信队列，人工介入处理，避免库存丢失。

#### 3. 库存扣减的性能瓶颈可能在哪里？如何优化（从数据库、缓存、锁、代码层面分别说明）？
**性能瓶颈核心点**：数据库IO、缓存命中率、锁竞争、代码冗余。

**分层优化方案**：
| 层面 | 可能的瓶颈 | 优化措施 |
|------|------------|----------|
| 数据库 | 1. 单库单表并发写入压力大；2. UPDATE语句执行慢；3. 主从复制延迟 | 1. 分库分表（按商品ID哈希分片）；2. 索引优化（`product_id`唯一索引，避免全表扫描）；3. 关闭事务自动提交，批量处理小事务；4. 主从分离（写主库，读从库）；5. 开启MySQL的`query_cache`（适用于读多写少） |
| 缓存 | 1. 缓存命中率低；2. Redis单机性能瓶颈；3. 缓存同步开销大 | 1. 缓存预热（热点商品提前加载）；2. 缓存永不过期（后台线程定期更新）；3. Redis Cluster集群（水平扩展，提升并发能力）；4. 异步同步缓存（消息队列/Canal）；5. 本地缓存（Caffeine）+ 分布式缓存（Redis）二级缓存 |
| 锁 | 1. 锁粒度太大（如全局锁）；2. 锁竞争激烈；3. 锁释放不及时 | 1. 细粒度锁（按商品ID加锁，而非全局锁）；2. 公平锁改为非公平锁（Redisson默认非公平锁，性能更高）；3. 减少锁持有时间（锁内只执行核心扣减逻辑，避免IO操作）；4. 锁超时时间合理设置（结合业务执行时间） |
| 代码 | 1. 同步代码块阻塞；2. 重复查询数据库；3. 事务范围过大 | 1. 异步化处理（如缓存同步、日志记录异步）；2. 数据复用（查询结果缓存到本地变量，避免重复查库）；3. 缩小事务范围（只包含数据库更新操作，避免锁持有过久）；4. 避免无效校验（如提前过滤负数数量请求） |

#### 4. 如何应对「恶意请求」（如高频重复扣减、超大数量扣减）？请设计限流、熔断、降级方案。
**恶意请求类型**：高频重复扣减（同一用户短时间内多次请求扣减）、超大数量扣减（一次扣减超过库存总量）、非法商品ID请求（缓存穿透）。

**防护方案**：
1. **限流方案**：
   - 接口限流：通过Sentinel限制单IP、单用户、单商品的并发请求数（如单用户每秒最多5次请求）。
   - 令牌桶算法：控制单位时间内的请求总量（如每秒10000次），超过则拒绝。
   - 实现：在Spring Boot中集成Sentinel，配置限流规则（如`@SentinelResource`注解）。
2. **熔断方案**：
   - 触发条件：当库存服务的错误率超过50%，或响应时间超过1秒，自动熔断。
   - 熔断后处理：返回友好提示（如「系统繁忙，请稍后重试」），避免请求继续压垮服务。
   - 实现：Sentinel支持熔断规则（慢调用比例、异常比例、异常数），熔断后定期尝试恢复。
3. **降级方案**：
   - 多级降级：
     - 一级降级：缓存宕机时，直接返回「库存不足」，不查询数据库。
     - 二级降级：数据库压力大时，限制单商品的扣减频率（如每秒最多100次更新）。
     - 三级降级：秒杀活动结束后，关闭库存扣减接口，返回「活动已结束」。
   - 实现：通过Sentinel的降级规则，结合业务逻辑判断（如数据库连接池占用率超过80%则降级）。
4. **额外防护**：
   - 参数校验：接口层校验扣减数量（如不能超过库存总量的10%）、商品ID合法性。
   - 幂等性设计：通过订单ID作为唯一标识，避免重复扣减（如Redis记录已处理的订单ID，重复请求直接返回成功）。

#### 5. 跨服务调用场景下（如订单服务调用库存服务），如何保证库存扣减与订单创建的原子性？（提示：分布式事务，2PC/TCC/SAGA/本地消息表）
**核心问题**：跨服务调用中，订单创建和库存扣减是两个独立的事务，需保证「要么都成功，要么都失败」，避免订单创建成功但库存未扣减（少卖）或库存扣减成功但订单未创建（超卖）。

**分布式事务方案对比与选择**：
| 方案 | 实现逻辑 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| 2PC（两阶段提交） | 1. 准备阶段：订单服务和库存服务执行预操作（如订单预创建、库存预扣减），返回是否就绪；2. 提交阶段：协调者收到所有就绪后，通知所有服务提交事务 | 强一致性 | 1. 阻塞性（准备阶段锁定资源）；2. 协调者单点故障风险；3. 性能差 | 金融场景（如支付+库存） |
| TCC（Try-Confirm-Cancel） | 1. Try：预操作（订单预创建、库存预扣减，锁定资源）；2. Confirm：确认操作（订单正式创建、库存正式扣减）；3. Cancel：取消操作（订单删除、库存释放） | 性能高（无锁阻塞）；强一致性 | 1. 代码侵入性强（需手动实现Try/Confirm/Cancel）；2. 幂等性要求高 | 高并发场景（如电商订单+库存） |
| SAGA | 将分布式事务拆分为多个本地事务，每个本地事务执行后发送消息触发下一个事务，失败则执行补偿事务 | 无阻塞；性能高；支持长事务 | 最终一致性；补偿逻辑复杂 | 长事务场景（如订单创建→库存扣减→物流创建） |
| 本地消息表 | 1. 订单服务创建订单，同时写入「库存扣减消息」到本地消息表；2. 定时任务扫描本地消息表，将未发送的消息发送到RocketMQ；3. 库存服务消费消息，扣减库存，返回成功后更新消息状态 | 实现简单；可靠性高 | 最终一致性；消息表冗余 | 中低并发场景（如普通电商订单） |

**推荐方案（高并发场景）：TCC**：
- 具体实现：
  1. Try阶段：
     - 订单服务：创建订单（状态为「待确认」），锁定订单资源。
     - 库存服务：预扣减库存（`available_stock -= quantity`，`locked_stock += quantity`），返回是否成功。
  2. Confirm阶段：
     - 订单服务：将订单状态改为「已确认」。
     - 库存服务：无额外操作（Try阶段已完成预扣减，Confirm仅确认）。
  3. Cancel阶段：
     - 订单服务：将订单状态改为「已取消」。
     - 库存服务：释放预扣减库存（`available_stock += quantity`，`locked_stock -= quantity`）。
  4. 幂等性保证：通过订单ID作为唯一标识，避免重复执行Confirm/Cancel。

### 四、问题排查与实战（全级别）
#### 1. 线上出现「库存为负数」的超卖问题，可能的原因有哪些？请逐步排查（从代码、缓存、数据库、分布式锁四个维度）。
**排查步骤**：
1. **代码层面**：
   - 检查是否存在「先查询后扣减」的非原子操作（如`SELECT available_stock`后直接`UPDATE`，无WHERE条件判断）。
   - 检查扣减逻辑是否有并发漏洞（如未加锁、锁释放过早）。
   - 检查是否有手动修改库存的代码（如后台管理系统直接修改库存，未走扣减流程）。
2. **缓存层面**：
   - 检查缓存与数据库是否不一致（如缓存库存大于数据库库存，导致请求穿透到数据库时扣减过量）。
   - 检查缓存是否被恶意修改（如Redis未授权访问，被篡改库存值）。
   - 检查缓存同步是否失败（如消息队列消费失败，导致数据库扣减后缓存未更新）。
3. **数据库层面**：
   - 检查UPDATE语句是否缺少`available_stock >= #{quantity}`条件（核心防超卖条件）。
   - 检查数据库事务隔离级别（如Read Uncommitted，导致脏读，多个事务同时扣减）。
   - 检查数据库是否有主从延迟（如从库查询到旧库存，导致订单服务误判库存充足）。
   - 检查是否有批量更新操作（如`UPDATE ... WHERE product_id IN (...)`，可能导致批量扣减过量）。
4. **分布式锁层面**：
   - 检查分布式锁是否生效（如锁Key错误，导致未锁住目标商品）。
   - 检查锁是否超时释放（如未开启看门狗，业务执行时间超过锁过期时间，导致锁提前释放）。
   - 检查Redis集群是否有故障（如主从切换导致锁丢失，多个节点同时获取锁）。

**常见解决方案**：
- 修复UPDATE语句，添加`available_stock >= #{quantity}`条件。
- 确保分布式锁Key正确（如`lock:stock:${productId}`），开启看门狗机制。
- 同步缓存与数据库库存（如通过定时任务补偿）。
- 恢复数据库事务隔离级别为Repeatable Read（MySQL默认）。

#### 2. 高并发下库存扣减响应变慢，如何定位瓶颈？（提示：数据库慢查询、锁竞争、缓存命中率低）
**定位流程**：
1. **监控指标采集**：
   - 应用层：通过SkyWalking/Prometheus监控接口响应时间、线程池状态（活跃线程数、队列长度）。
   - 缓存层：通过Redis监控工具（如Redis Insight）查看缓存命中率、QPS、响应时间。
   - 数据库层：通过MySQL慢查询日志（`slow_query_log`）、Performance Schema监控慢查询、锁等待时间、连接数。
   - 分布式锁：通过Redisson监控锁竞争次数、获取锁耗时。
2. **瓶颈定位**：
   - 若缓存命中率低于90%：瓶颈在缓存（如缓存未预热、缓存过期、Key设计错误）。
   - 若数据库慢查询较多（如UPDATE语句执行时间超过100ms）：瓶颈在数据库（如索引缺失、分库分表未生效）。
   - 若锁竞争次数高（如Redisson的`lock_acquire_time`超过50ms）：瓶颈在分布式锁（如锁粒度太大、锁持有时间过长）。
   - 若应用线程池队列满：瓶颈在应用层（如并发请求数超过线程池承载能力）。
3. **针对性优化**：
   - 缓存命中率低：缓存预热、调整缓存过期时间、优化Key设计（如避免缓存穿透）。
   - 数据库慢查询：添加索引、优化SQL、分库分表、主从分离。
   - 锁竞争激烈：缩小锁粒度、减少锁持有时间、改用非公平锁。
   - 应用线程池满：扩容线程池、增加应用节点、限流熔断。

#### 3. Redis缓存宕机后，库存扣减服务如何保障可用性？是否会出现超卖？
**可用性保障方案**：
1. **降级方案**：Redis宕机后，直接降级到数据库，通过数据库的原子更新（`UPDATE ... WHERE available_stock >= #{quantity}`）保证库存扣减的一致性，同时返回友好提示（如「系统繁忙，请稍后重试」）。
2. **熔断方案**：通过Sentinel监控Redis的可用性，当Redis宕机时，自动熔断缓存层，避免应用线程阻塞在Redis连接上。
3. **Redis集群容灾**：部署Redis Cluster（3主3从），主节点宕机后，从节点自动切换为主节点，确保Redis服务可用性（RTO<30秒）。
4. **限流方案**：Redis宕机后，数据库压力会突增，通过限流限制单商品的并发扣减请求数（如每秒500次），避免数据库被击垮。

**是否会超卖？**：不会。
- 核心原因：即使Redis缓存宕机，所有请求穿透到数据库，数据库的UPDATE语句通过`available_stock >= #{quantity}`条件保证原子性扣减，避免超卖。
- 注意事项：需确保数据库能承载峰值流量（如通过分库分表、主从分离提升数据库并发能力），否则可能导致数据库宕机，服务不可用。

#### 4. 某商品库存为100，同时有100个请求各扣减1件，但最终数据库库存剩余10，可能的原因是什么？
**可能的原因**：
1. **缓存与数据库一致性问题**：缓存库存大于数据库库存（如缓存未同步），导致部分请求从缓存读取到充足库存，穿透到数据库时，数据库库存已不足，但因代码逻辑未再次校验数据库库存，导致扣减失败但未处理，最终实际扣减90次。
2. **分布式锁失效**：分布式锁未锁住目标商品（如锁Key错误、Redis集群故障导致锁丢失），导致多个节点同时执行扣减，部分扣减请求因库存不足失败，但失败后未同步缓存，后续请求仍从缓存读取旧值，重复尝试扣减。
3. **事务回滚未释放库存**：部分请求扣减库存后，因其他业务逻辑失败（如订单创建失败）导致事务回滚，但库存扣减未回滚（如库存扣减未纳入事务），导致实际扣减次数少于请求次数。
4. **库存锁定未释放**：部分请求下单后未支付，库存被锁定在`locked_stock`字段，未释放回`available_stock`，导致数据库`available_stock`剩余10，但实际锁定库存90，总库存仍为100。
5. **代码逻辑错误**：扣减数量计算错误（如代码中写成`available_stock -= quantity * 2`），导致实际扣减数量超过请求数量。

**排查步骤**：
- 查看数据库`product_stock`表的`available_stock`和`locked_stock`字段，确认是否有锁定库存未释放。
- 查看应用日志，统计库存扣减成功的次数，是否与数据库扣减次数一致。
- 检查分布式锁日志，确认锁是否生效，是否有多个节点同时获取锁。
- 检查事务范围，确认库存扣减是否纳入事务，事务回滚时是否释放库存。

#### 5. 如何设计库存扣减的监控告警体系？需要监控哪些指标（如扣减成功率、锁竞争率、缓存命中率）？
**监控告警体系设计**：
- 监控工具：Prometheus + Grafana（指标采集与可视化）、SkyWalking（链路追踪）、ELK（日志分析）、钉钉/邮件（告警通知）。
- 告警级别：P0（致命，如库存超卖）、P1（严重，如响应时间超1秒）、P2（普通，如缓存命中率低）。

**核心监控指标**：
以下是库存扣减面试题的详细参考答案，结合Java后端技术栈（Spring Boot、分布式、高并发），兼顾原理、实现方案与实战经验，逻辑清晰且贴合面试场景：

### 一、基础概念与核心问题（初级/中级）
#### 1. 库存扣减业务中最核心的问题是什么？如何避免「超卖」？请列举至少2种实现方案，并说明各自的优缺点。
**核心问题**：并发场景下的「数据一致性」，即避免超卖（库存为负）、少卖（库存未扣减但订单已创建），同时兼顾性能。

**避免超卖的核心方案**：
| 方案 | 实现逻辑 | 优点 | 缺点 |
|------|----------|------|------|
| 数据库原子更新（WHERE条件控制） | 直接执行 `UPDATE product_stock SET available_stock = available_stock - #{num} WHERE product_id = #{id} AND available_stock >= #{num}` | 1. 无需额外组件，实现简单；2. 数据库层面保证原子性，无超卖风险；3. 适合中低并发场景 | 1. 高并发下数据库压力大（所有请求穿透到DB）；2. 无缓存隔离，响应速度受限 |
| 乐观锁（Version版本号） | 库存表加`version`字段，更新时带版本号：`UPDATE ... WHERE product_id = #{id} AND version = #{version} AND available_stock >= #{num}`，更新成功则version+1 | 1. 无锁竞争，高并发下性能优于悲观锁；2. 支持高并发读场景 | 1. 冲突频繁时（如秒杀），重试次数多，用户体验差；2. 需要处理重试逻辑（如循环重试或返回失败） |
| 悲观锁（数据库行锁） | 用`SELECT ... FOR UPDATE`查询库存并加行锁，再执行扣减：`BEGIN; SELECT available_stock FROM product_stock WHERE product_id = #{id} FOR UPDATE; UPDATE ...; COMMIT;` | 1. 强一致性，适合写多读少场景；2. 逻辑直观，无需重试 | 1. 锁竞争严重，高并发下会导致线程阻塞，性能差；2. 可能出现死锁风险（需控制事务时长） |

#### 2. 为什么直接使用「先查询库存（SELECT）再扣减（UPDATE）」的逻辑会导致超卖？请从并发原理层面解释。
**本质原因**：「查询-扣减」是两步操作，非原子性，存在并发竞争导致的「race condition」（竞态条件）。

**原理分析**：
- 高并发下，多个线程同时执行`SELECT available_stock FROM product_stock WHERE product_id = 1`，假设查询结果均为10。
- 线程A执行`UPDATE ... SET available_stock = 10 - 1 = 9`，线程B同时执行`UPDATE ... SET available_stock = 10 - 1 = 9`。
- 最终库存扣减2次，但实际只减少了1，导致「少扣减」；若初始库存为1，两个线程同时查询到1，都执行扣减，则库存变为-1，导致「超卖」。
- 核心问题：两步操作之间无锁保护，中间状态可被其他线程修改，破坏了数据一致性。

#### 3. 数据库层面如何通过SQL实现原子性的库存扣减？请写出核心SQL，并说明WHERE条件的作用。
**核心SQL**：
```sql
UPDATE product_stock
SET available_stock = available_stock - #{quantity},
    update_time = NOW()
WHERE product_id = #{productId} 
  AND available_stock >= #{quantity}; -- 关键条件：保证库存充足
```

**WHERE条件的作用**：
1. **原子性保证**：UPDATE语句是数据库层面的原子操作，同一时间只有一个事务能修改该记录（InnoDB行锁），避免并发冲突。
2. **防超卖**：`available_stock >= #{quantity}` 确保只有库存充足时才执行扣减，库存不足则更新行数为0，直接返回失败。
3. **无需额外锁**：无需手动加悲观锁，依赖数据库行锁和SQL原子性，简化逻辑。

#### 4. 乐观锁和悲观锁在库存扣减场景中如何应用？分别适用于什么业务场景（高并发/低并发）？
**乐观锁应用**：
- 实现方式：库存表加`version`字段，更新时携带版本号，更新成功则版本号自增。
  ```sql
  UPDATE product_stock
  SET available_stock = available_stock - #{quantity},
      version = version + 1
  WHERE product_id = #{productId} 
    AND available_stock >= #{quantity}
    AND version = #{version}; -- 版本号匹配才更新
  ```
- 业务场景：**高并发读多写少**（如普通商品库存扣减，并发请求多但实际扣减频率低），优点是无锁竞争，性能高；缺点是冲突时需重试。

**悲观锁应用**：
- 实现方式：通过`SELECT ... FOR UPDATE`加行锁，确保事务期间其他线程无法修改该记录。
  ```sql
  BEGIN; -- 开启事务
  -- 查询并加行锁（InnoDB默认行锁，需索引命中）
  SELECT available_stock FROM product_stock WHERE product_id = #{productId} FOR UPDATE;
  -- 扣减库存（此时库存已被锁定，其他线程需等待）
  UPDATE product_stock SET available_stock = available_stock - #{quantity} WHERE product_id = #{productId};
  COMMIT; -- 提交事务，释放锁
  ```
- 业务场景：**低并发写多读少**（如高端商品限量发售，并发请求少但需强一致性），优点是逻辑简单，无重试；缺点是锁竞争导致阻塞，高并发下性能差。

#### 5. 库存扣减时，除了「可用库存」，是否需要设计「锁定库存」字段？请说明使用场景（如订单未支付时的库存占用）。
**需要设计「锁定库存」字段**，核心用于「库存占用-确认扣减-释放库存」的完整流程，避免超卖同时提升用户体验。

**核心场景**：订单创建后未支付（如电商下单后15分钟未支付自动取消）。
- 流程设计：
  1. 用户下单时，先将「可用库存」转为「锁定库存」：`UPDATE product_stock SET available_stock = available_stock - #{num}, locked_stock = locked_stock + #{num} WHERE product_id = #{id} AND available_stock >= #{num}`。
  2. 用户支付成功：将「锁定库存」扣减（确认扣减）：`UPDATE product_stock SET locked_stock = locked_stock - #{num} WHERE product_id = #{id}`。
  3. 用户未支付/取消订单：释放「锁定库存」回「可用库存」：`UPDATE product_stock SET available_stock = available_stock + #{num}, locked_stock = locked_stock - #{num} WHERE product_id = #{id}`。
- 核心价值：避免订单未支付时库存被其他用户占用，同时防止用户支付后无库存，平衡「可用性」和「一致性」。

### 二、分布式与高并发场景（中级/高级）
#### 1. 分布式部署（多节点）下，库存扣减如何保证并发安全？分布式锁的实现方案有哪些（Redis/ZooKeeper/数据库）？各自的优缺点是什么？
**分布式并发安全核心**：多节点共享同一库存数据，需通过「分布式锁」实现跨节点的互斥操作，确保同一商品的库存扣减同一时间只有一个节点执行。

**分布式锁实现方案对比**：
| 方案 | 实现逻辑 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| Redis分布式锁（Redisson） | 基于Redis的`SET NX EX`命令（原子操作），加锁时设置过期时间，Redisson提供看门狗机制自动续期 | 1. 性能高（Redis单机QPS万级）；2. 部署简单；3. 支持可重入、公平锁等特性 | 1.  Redis单点故障风险（需集群部署）；2. 主从切换时可能出现锁丢失（需红锁方案） | 高并发场景（如秒杀、电商库存） |
| ZooKeeper分布式锁 | 基于ZooKeeper的临时有序节点，客户端创建节点后，监听前序节点，前序节点删除则竞争锁 | 1. 强一致性（CP），无锁丢失风险；2. 支持公平锁；3. 崩溃自动释放锁 | 1. 性能低（ZooKeeper QPS千级）；2. 部署复杂（需集群） | 强一致性场景（如金融库存、支付） |
| 数据库分布式锁 | 基于数据库表（如`distributed_lock`），通过`INSERT`加锁（唯一索引保证互斥），`DELETE`释放锁 | 1. 实现简单（无需额外组件）；2. 无需担心第三方依赖 | 1. 性能差（数据库压力大）；2. 可能出现死锁（需设置过期时间）；3. 单点故障（需主从） | 低并发、小型系统 |

#### 2. Redisson分布式锁的「看门狗机制」是什么？在库存扣减场景中如何避免锁超时导致的超卖？
**看门狗机制**：Redisson的分布式锁默认开启看门狗（Watch Dog），当用户未指定锁的过期时间时，锁默认过期时间为30秒，Redisson会启动一个后台线程，每隔10秒（过期时间的1/3）自动为锁续期，确保锁在业务执行期间不失效。

**避免锁超时超卖的方案**：
1. **开启看门狗自动续期**：使用Redisson的`RLock`时，不指定过期时间（或通过`lock()`方法），看门狗会自动续期，直到业务执行完成释放锁。
   ```java
   RLock lock = redissonClient.getLock("lock:stock:" + productId);
   lock.lock(); // 无过期时间，看门狗自动续期
   try {
       // 库存扣减逻辑
   } finally {
       lock.unlock();
   }
   ```
2. **手动设置足够长的过期时间**：若明确业务执行时间（如库存扣减最多5秒），可设置过期时间为10秒，避免锁提前过期。
3. **业务超时控制**：在锁内执行业务时，设置超时时间（如通过`CompletableFuture`超时中断），避免业务执行过长导致锁续期失败。

#### 3. 高并发（QPS 1000+）场景下，如何减少数据库压力？Redis缓存库存时，需要注意哪些问题（缓存穿透/击穿/雪崩）？如何解决？
**减少数据库压力的核心方案**：
1. **Redis缓存前置**：将库存数据缓存到Redis，查询先查Redis，缓存命中则无需访问数据库（缓存命中率需达到99%以上）。
2. **缓存预热**：系统启动时，将热点商品库存批量加载到Redis，避免缓存穿透。
3. **异步同步缓存**：库存扣减后，通过消息队列（如RocketMQ）异步同步数据库数据到Redis，减少同步更新的性能损耗。
4. **限流熔断**：通过Sentinel限制单商品的并发扣减请求数，避免数据库被突发流量击垮。

**Redis缓存核心问题及解决方案**：
| 问题 | 定义 | 解决方案 |
|------|------|----------|
| 缓存穿透 | 恶意请求查询不存在的商品ID，缓存和数据库都无数据，导致请求直接穿透到数据库 | 1. 布隆过滤器过滤不存在的商品ID；2. 缓存空值（设置短期过期时间，如5分钟）；3. 接口层校验商品ID合法性 |
| 缓存击穿 | 热点商品的缓存过期，大量请求同时穿透到数据库，导致数据库压力突增 | 1. 缓存永不过期（通过后台线程定期更新）；2. 互斥锁（缓存过期时，只有一个线程查询数据库并更新缓存）；3. 预热热点商品缓存 |
| 缓存雪崩 | 大量缓存同时过期（如整点过期），或Redis集群宕机，导致所有请求穿透到数据库 | 1. 缓存过期时间随机化（如加1-5分钟随机值）；2. Redis集群部署（主从+哨兵）；3. 降级方案（缓存宕机时，直接返回库存不足，保护数据库） |

#### 4. 缓存与数据库的一致性如何保障？库存扣减时，是「先更数据库再更缓存」还是「先更缓存再更数据库」？请说明理由及可能的问题。
**缓存与数据库一致性核心原则**：高并发场景下，优先保证「最终一致性」，避免因强一致性导致性能瓶颈。

**两种更新策略对比**：
| 策略 | 流程 | 优点 | 可能的问题 | 解决方案 |
|------|------|------|------------|----------|
| 先更数据库，再更缓存 | 数据库扣减库存 → 缓存扣减库存 | 逻辑直观，数据库更新成功后同步缓存 | 1. 数据库更新成功，缓存更新失败 → 缓存脏数据；2. 高并发下，两次更新请求顺序颠倒（如线程A先更DB，线程B后更DB，线程B先更缓存，线程A后更缓存） → 缓存脏数据 | 1. 缓存更新失败重试（结合消息队列）；2. 采用「先删缓存再更数据库」+ 延迟双删 |
| 先更缓存，再更数据库 | 缓存扣减库存 → 数据库扣减库存 | 缓存更新快，能快速响应后续请求 | 1. 缓存更新成功，数据库更新失败 → 缓存脏数据（库存已扣减但DB未变）；2. 高并发下，缓存更新后DB未更新，其他线程查询缓存得到脏数据 | 几乎不推荐，仅适用于允许短暂不一致的场景（如非核心商品） |

**推荐策略：先删缓存再更数据库 + 延迟双删**：
1. 流程：删除缓存 → 数据库扣减库存 → 延迟1-3秒再次删除缓存。
2. 核心逻辑：
   - 第一次删除缓存：避免后续请求读取旧缓存。
   - 数据库更新：保证数据一致性。
   - 延迟双删：解决「数据库更新后，缓存被其他线程重新写入旧数据」的问题（如线程A删除缓存→线程B查询DB→线程A更新DB→线程B写入旧缓存，延迟双删可删除该旧缓存）。
3. 实现方式：延迟双删可通过`Thread.sleep()`（简单场景）或消息队列（高并发场景）实现。

#### 5. 库存扣减的「最终一致性」和「强一致性」如何选择？如果业务允许短暂的库存不一致（如秒杀后1分钟内同步），可以设计哪些方案？
**一致性选择原则**：根据业务场景的「一致性要求」和「性能要求」权衡：
- 强一致性：适用于金融、支付等核心场景（如库存扣减后必须立即反映到数据库，不允许任何不一致）。
- 最终一致性：适用于电商、秒杀等高并发场景（允许短暂不一致，但需在合理时间内同步）。

**最终一致性方案设计**：
1. **消息队列异步同步**：
   - 流程：库存扣减 → 发送消息到队列 → 消费者消费消息，同步缓存和数据库 → 失败重试。
   - 核心：通过消息队列的可靠性投递（如RocketMQ的事务消息）保证同步不丢失，最终实现数据一致。
2. **数据库binlog同步缓存**：
   - 流程：数据库扣减库存（生成binlog） → Canal监听binlog → 解析binlog并更新Redis缓存。
   - 核心：无需业务代码干预，通过中间件实现异步同步，性能高且一致性强。
3. **定时任务补偿**：
   - 流程：后台定时任务（如每分钟）查询数据库和缓存的库存差异 → 同步不一致的数据。
   - 核心：兜底方案，解决消息队列或binlog同步失败的问题，确保最终一致性。

### 三、架构设计与优化（高级/架构师）
#### 1. 设计一套支持「秒杀场景」的库存扣减系统（QPS 10000+，5个节点部署），请画出架构图，并说明核心组件（缓存、锁、数据库、消息队列）的作用。
**架构图（文字描述）**：
```
用户 → CDN → 负载均衡（Nginx） → 5个应用节点（Spring Boot） → 限流熔断（Sentinel） → 分布式锁（Redis Cluster）
                                                                 ↓
                                                            缓存层（Redis Cluster）
                                                                 ↓
                                                            消息队列（RocketMQ）
                                                                 ↓
                                                            数据库层（MySQL主从+分库分表）
```

**核心组件作用**：
1. **CDN**：缓存静态资源（如秒杀页面），减少应用节点压力。
2. **负载均衡（Nginx）**：将请求均匀分发到5个应用节点，实现负载分担。
3. **限流熔断（Sentinel）**：
   - 限流：限制单商品的并发请求数（如每秒10000次），避免超阈值请求压垮系统。
   - 熔断：当库存服务异常（如响应时间超过500ms），自动降级返回「活动火爆，请稍后重试」，保护核心流程。
4. **分布式锁（Redis Cluster）**：
   - 作用：实现跨节点的互斥操作，确保同一商品的库存扣减同一时间只有一个节点执行，避免超卖。
   - 配置：Redis Cluster集群（3主3从），Redisson客户端，开启看门狗机制。
5. **缓存层（Redis Cluster）**：
   - 作用：缓存热点商品库存，拦截99%以上的查询请求，减少数据库压力。
   - 优化：缓存预热（秒杀前加载库存）、缓存永不过期（后台线程定期更新）、防止缓存穿透/击穿/雪崩。
6. **消息队列（RocketMQ）**：
   - 削峰填谷：接收高并发的库存扣减请求，异步消费，避免数据库被突发流量击垮。
   - 异步同步：消费消息时同步数据库和缓存，实现最终一致性。
   - 库存回滚：订单取消时，通过消息队列触发库存释放。
7. **数据库层（MySQL主从+分库分表）**：
   - 主从复制：主库写入库存扣减，从库负责查询，分担读压力。
   - 分库分表：按商品ID哈希分片（如分8个库16个表），解决单库单表性能瓶颈。
   - 索引优化：`product_id`唯一索引，`available_stock`普通索引，提升更新和查询效率。

#### 2. 消息队列在库存扣减场景中能解决什么问题？如何通过消息队列实现「异步扣减」「库存回滚」（如订单取消后释放库存）？
**消息队列核心作用**：
1. **削峰填谷**：高并发场景下，请求先写入消息队列，避免直接冲击数据库，将瞬时高流量转为平稳流量。
2. **异步解耦**：库存扣减与订单创建、支付等流程解耦，库存服务只需关注自身逻辑，通过消息队列通信。
3. **可靠性保证**：支持消息重试、死信队列，确保库存扣减和回滚不丢失。
4. **最终一致性**：通过异步消费实现缓存与数据库的同步，保证数据最终一致。

**异步扣减实现**：
1. 流程：用户下单 → 订单服务发送「库存扣减消息」到RocketMQ → 库存服务消费消息 → 执行库存扣减（Redis+数据库） → 消费成功返回ACK，失败则重试（最多3次）。
2. 关键：消息队列设置 Topic 为`stock-deduct-topic`，库存服务作为消费者，通过集群部署提高消费能力，确保消息不堆积。

**库存回滚实现**：
1. 流程：用户取消订单 → 订单服务发送「库存回滚消息」到RocketMQ（设置延迟队列，如15分钟未支付自动触发） → 库存服务消费消息 → 执行库存释放（`available_stock += quantity`） → 同步缓存。
2. 关键：
   - 消息携带订单ID和商品ID、数量，确保回滚精准。
   - 死信队列：回滚失败的消息（如数据库异常）进入死信队列，人工介入处理，避免库存丢失。

#### 3. 库存扣减的性能瓶颈可能在哪里？如何优化（从数据库、缓存、锁、代码层面分别说明）？
**性能瓶颈核心点**：数据库IO、缓存命中率、锁竞争、代码冗余。

**分层优化方案**：
| 层面 | 可能的瓶颈 | 优化措施 |
|------|------------|----------|
| 数据库 | 1. 单库单表并发写入压力大；2. UPDATE语句执行慢；3. 主从复制延迟 | 1. 分库分表（按商品ID哈希分片）；2. 索引优化（`product_id`唯一索引，避免全表扫描）；3. 关闭事务自动提交，批量处理小事务；4. 主从分离（写主库，读从库）；5. 开启MySQL的`query_cache`（适用于读多写少） |
| 缓存 | 1. 缓存命中率低；2. Redis单机性能瓶颈；3. 缓存同步开销大 | 1. 缓存预热（热点商品提前加载）；2. 缓存永不过期（后台线程定期更新）；3. Redis Cluster集群（水平扩展，提升并发能力）；4. 异步同步缓存（消息队列/Canal）；5. 本地缓存（Caffeine）+ 分布式缓存（Redis）二级缓存 |
| 锁 | 1. 锁粒度太大（如全局锁）；2. 锁竞争激烈；3. 锁释放不及时 | 1. 细粒度锁（按商品ID加锁，而非全局锁）；2. 公平锁改为非公平锁（Redisson默认非公平锁，性能更高）；3. 减少锁持有时间（锁内只执行核心扣减逻辑，避免IO操作）；4. 锁超时时间合理设置（结合业务执行时间） |
| 代码 | 1. 同步代码块阻塞；2. 重复查询数据库；3. 事务范围过大 | 1. 异步化处理（如缓存同步、日志记录异步）；2. 数据复用（查询结果缓存到本地变量，避免重复查库）；3. 缩小事务范围（只包含数据库更新操作，避免锁持有过久）；4. 避免无效校验（如提前过滤负数数量请求） |

#### 4. 如何应对「恶意请求」（如高频重复扣减、超大数量扣减）？请设计限流、熔断、降级方案。
**恶意请求类型**：高频重复扣减（同一用户短时间内多次请求扣减）、超大数量扣减（一次扣减超过库存总量）、非法商品ID请求（缓存穿透）。

**防护方案**：
1. **限流方案**：
   - 接口限流：通过Sentinel限制单IP、单用户、单商品的并发请求数（如单用户每秒最多5次请求）。
   - 令牌桶算法：控制单位时间内的请求总量（如每秒10000次），超过则拒绝。
   - 实现：在Spring Boot中集成Sentinel，配置限流规则（如`@SentinelResource`注解）。
2. **熔断方案**：
   - 触发条件：当库存服务的错误率超过50%，或响应时间超过1秒，自动熔断。
   - 熔断后处理：返回友好提示（如「系统繁忙，请稍后重试」），避免请求继续压垮服务。
   - 实现：Sentinel支持熔断规则（慢调用比例、异常比例、异常数），熔断后定期尝试恢复。
3. **降级方案**：
   - 多级降级：
     - 一级降级：缓存宕机时，直接返回「库存不足」，不查询数据库。
     - 二级降级：数据库压力大时，限制单商品的扣减频率（如每秒最多100次更新）。
     - 三级降级：秒杀活动结束后，关闭库存扣减接口，返回「活动已结束」。
   - 实现：通过Sentinel的降级规则，结合业务逻辑判断（如数据库连接池占用率超过80%则降级）。
4. **额外防护**：
   - 参数校验：接口层校验扣减数量（如不能超过库存总量的10%）、商品ID合法性。
   - 幂等性设计：通过订单ID作为唯一标识，避免重复扣减（如Redis记录已处理的订单ID，重复请求直接返回成功）。

#### 5. 跨服务调用场景下（如订单服务调用库存服务），如何保证库存扣减与订单创建的原子性？（提示：分布式事务，2PC/TCC/SAGA/本地消息表）
**核心问题**：跨服务调用中，订单创建和库存扣减是两个独立的事务，需保证「要么都成功，要么都失败」，避免订单创建成功但库存未扣减（少卖）或库存扣减成功但订单未创建（超卖）。

**分布式事务方案对比与选择**：
以下是格式规范、可直接复制使用的 Markdown 表格（与你提供的指标内容完全一致，优化了对齐和可读性）：

| 指标类型 | 具体指标        | 告警阈值          | 监控目的           |
| ---- | ----------- | ------------- | -------------- |
| 业务指标 | 库存扣减成功率     | <99%（P1）      | 确保大部分请求正常扣减    |
| 业务指标 | 超卖次数        | >0（P0）        | 立即处理超卖问题       |
| 业务指标 | 库存锁定超时次数    | >100次/分钟（P2）  | 避免锁定库存过多导致库存积压 |
| 性能指标 | 接口响应时间      | >500ms（P1）    | 确保接口性能达标       |
| 性能指标 | 数据库UPDATE耗时 | >100ms（P2）    | 监控数据库性能        |
| 缓存指标 | 缓存命中率       | <95%（P2）      | 确保缓存有效拦截请求     |
| 缓存指标 | 缓存穿透次数      | >100次/分钟（P2）  | 防止恶意请求攻击       |
| 锁指标  | 分布式锁竞争率     | >30%（P2）      | 避免锁竞争导致性能下降    |
| 锁指标  | 锁获取失败次数     | >50次/分钟（P1）   | 确保分布式锁生效       |
| 系统指标 | 应用线程池活跃线程数  | >80%线程池大小（P2） | 避免应用线程阻塞       |
| 系统指标 | 数据库连接池使用率   | >80%（P2）      | 防止数据库连接耗尽      |

直接复制到 Markdown 编辑器（如 Typora、VS Code、GitLab/GitHub 文档）中即可正常渲染，无需额外调整格式。

**推荐方案（高并发场景）：TCC**：
- 具体实现：
  1. Try阶段：
     - 订单服务：创建订单（状态为「待确认」），锁定订单资源。
     - 库存服务：预扣减库存（`available_stock -= quantity`，`locked_stock += quantity`），返回是否成功。
  2. Confirm阶段：
     - 订单服务：将订单状态改为「已确认」。
     - 库存服务：无额外操作（Try阶段已完成预扣减，Confirm仅确认）。
  3. Cancel阶段：
     - 订单服务：将订单状态改为「已取消」。
     - 库存服务：释放预扣减库存（`available_stock += quantity`，`locked_stock -= quantity`）。
  4. 幂等性保证：通过订单ID作为唯一标识，避免重复执行Confirm/Cancel。

### 四、问题排查与实战（全级别）
#### 1. 线上出现「库存为负数」的超卖问题，可能的原因有哪些？请逐步排查（从代码、缓存、数据库、分布式锁四个维度）。
**排查步骤**：
1. **代码层面**：
   - 检查是否存在「先查询后扣减」的非原子操作（如`SELECT available_stock`后直接`UPDATE`，无WHERE条件判断）。
   - 检查扣减逻辑是否有并发漏洞（如未加锁、锁释放过早）。
   - 检查是否有手动修改库存的代码（如后台管理系统直接修改库存，未走扣减流程）。
2. **缓存层面**：
   - 检查缓存与数据库是否不一致（如缓存库存大于数据库库存，导致请求穿透到数据库时扣减过量）。
   - 检查缓存是否被恶意修改（如Redis未授权访问，被篡改库存值）。
   - 检查缓存同步是否失败（如消息队列消费失败，导致数据库扣减后缓存未更新）。
3. **数据库层面**：
   - 检查UPDATE语句是否缺少`available_stock >= #{quantity}`条件（核心防超卖条件）。
   - 检查数据库事务隔离级别（如Read Uncommitted，导致脏读，多个事务同时扣减）。
   - 检查数据库是否有主从延迟（如从库查询到旧库存，导致订单服务误判库存充足）。
   - 检查是否有批量更新操作（如`UPDATE ... WHERE product_id IN (...)`，可能导致批量扣减过量）。
4. **分布式锁层面**：
   - 检查分布式锁是否生效（如锁Key错误，导致未锁住目标商品）。
   - 检查锁是否超时释放（如未开启看门狗，业务执行时间超过锁过期时间，导致锁提前释放）。
   - 检查Redis集群是否有故障（如主从切换导致锁丢失，多个节点同时获取锁）。

**常见解决方案**：
- 修复UPDATE语句，添加`available_stock >= #{quantity}`条件。
- 确保分布式锁Key正确（如`lock:stock:${productId}`），开启看门狗机制。
- 同步缓存与数据库库存（如通过定时任务补偿）。
- 恢复数据库事务隔离级别为Repeatable Read（MySQL默认）。

#### 2. 高并发下库存扣减响应变慢，如何定位瓶颈？（提示：数据库慢查询、锁竞争、缓存命中率低）
**定位流程**：
1. **监控指标采集**：
   - 应用层：通过SkyWalking/Prometheus监控接口响应时间、线程池状态（活跃线程数、队列长度）。
   - 缓存层：通过Redis监控工具（如Redis Insight）查看缓存命中率、QPS、响应时间。
   - 数据库层：通过MySQL慢查询日志（`slow_query_log`）、Performance Schema监控慢查询、锁等待时间、连接数。
   - 分布式锁：通过Redisson监控锁竞争次数、获取锁耗时。
2. **瓶颈定位**：
   - 若缓存命中率低于90%：瓶颈在缓存（如缓存未预热、缓存过期、Key设计错误）。
   - 若数据库慢查询较多（如UPDATE语句执行时间超过100ms）：瓶颈在数据库（如索引缺失、分库分表未生效）。
   - 若锁竞争次数高（如Redisson的`lock_acquire_time`超过50ms）：瓶颈在分布式锁（如锁粒度太大、锁持有时间过长）。
   - 若应用线程池队列满：瓶颈在应用层（如并发请求数超过线程池承载能力）。
3. **针对性优化**：
   - 缓存命中率低：缓存预热、调整缓存过期时间、优化Key设计（如避免缓存穿透）。
   - 数据库慢查询：添加索引、优化SQL、分库分表、主从分离。
   - 锁竞争激烈：缩小锁粒度、减少锁持有时间、改用非公平锁。
   - 应用线程池满：扩容线程池、增加应用节点、限流熔断。

#### 3. Redis缓存宕机后，库存扣减服务如何保障可用性？是否会出现超卖？
**可用性保障方案**：
1. **降级方案**：Redis宕机后，直接降级到数据库，通过数据库的原子更新（`UPDATE ... WHERE available_stock >= #{quantity}`）保证库存扣减的一致性，同时返回友好提示（如「系统繁忙，请稍后重试」）。
2. **熔断方案**：通过Sentinel监控Redis的可用性，当Redis宕机时，自动熔断缓存层，避免应用线程阻塞在Redis连接上。
3. **Redis集群容灾**：部署Redis Cluster（3主3从），主节点宕机后，从节点自动切换为主节点，确保Redis服务可用性（RTO<30秒）。
4. **限流方案**：Redis宕机后，数据库压力会突增，通过限流限制单商品的并发扣减请求数（如每秒500次），避免数据库被击垮。

**是否会超卖？**：不会。
- 核心原因：即使Redis缓存宕机，所有请求穿透到数据库，数据库的UPDATE语句通过`available_stock >= #{quantity}`条件保证原子性扣减，避免超卖。
- 注意事项：需确保数据库能承载峰值流量（如通过分库分表、主从分离提升数据库并发能力），否则可能导致数据库宕机，服务不可用。

#### 4. 某商品库存为100，同时有100个请求各扣减1件，但最终数据库库存剩余10，可能的原因是什么？
**可能的原因**：
1. **缓存与数据库一致性问题**：缓存库存大于数据库库存（如缓存未同步），导致部分请求从缓存读取到充足库存，穿透到数据库时，数据库库存已不足，但因代码逻辑未再次校验数据库库存，导致扣减失败但未处理，最终实际扣减90次。
2. **分布式锁失效**：分布式锁未锁住目标商品（如锁Key错误、Redis集群故障导致锁丢失），导致多个节点同时执行扣减，部分扣减请求因库存不足失败，但失败后未同步缓存，后续请求仍从缓存读取旧值，重复尝试扣减。
3. **事务回滚未释放库存**：部分请求扣减库存后，因其他业务逻辑失败（如订单创建失败）导致事务回滚，但库存扣减未回滚（如库存扣减未纳入事务），导致实际扣减次数少于请求次数。
4. **库存锁定未释放**：部分请求下单后未支付，库存被锁定在`locked_stock`字段，未释放回`available_stock`，导致数据库`available_stock`剩余10，但实际锁定库存90，总库存仍为100。
5. **代码逻辑错误**：扣减数量计算错误（如代码中写成`available_stock -= quantity * 2`），导致实际扣减数量超过请求数量。

**排查步骤**：
- 查看数据库`product_stock`表的`available_stock`和`locked_stock`字段，确认是否有锁定库存未释放。
- 查看应用日志，统计库存扣减成功的次数，是否与数据库扣减次数一致。
- 检查分布式锁日志，确认锁是否生效，是否有多个节点同时获取锁。
- 检查事务范围，确认库存扣减是否纳入事务，事务回滚时是否释放库存。

#### 5. 如何设计库存扣减的监控告警体系？需要监控哪些指标（如扣减成功率、锁竞争率、缓存命中率）？
**监控告警体系设计**：
- 监控工具：Prometheus + Grafana（指标采集与可视化）、SkyWalking（链路追踪）、ELK（日志分析）、钉钉/邮件（告警通知）。
- 告警级别：P0（致命，如库存超卖）、P1（严重，如响应时间超1秒）、P2（普通，如缓存命中率低）。

**核心监控指标**：


| 指标类型 | 具体指标        | 告警阈值          | 监控目的           |
| ---- | ----------- | ------------- | -------------- |
| 业务指标 | 库存扣减成功率     | <99%（P1）      | 确保大部分请求正常扣减    |
| 业务指标 | 超卖次数        | >0（P0）        | 立即处理超卖问题       |
| 业务指标 | 库存锁定超时次数    | >100次/分钟（P2）  | 避免锁定库存过多导致库存积压 |
| 性能指标 | 接口响应时间      | >500ms（P1）    | 确保接口性能达标       |
| 性能指标 | 数据库UPDATE耗时 | >100ms（P2）    | 监控数据库性能        |
| 缓存指标 | 缓存命中率       | <95%（P2）      | 确保缓存有效拦截请求     |
| 缓存指标 | 缓存穿透次数      | >100次/分钟（P2）  | 防止恶意请求攻击       |
| 锁指标  | 分布式锁竞争率     | >30%（P2）      | 避免锁竞争导致性能下降    |
| 锁指标  | 锁获取失败次数     | >50次/分钟（P1）   | 确保分布式锁生效       |
| 系统指标 | 应用线程池活跃线程数  | >80%线程池大小（P2） | 避免应用线程阻塞       |
| 系统指标 | 数据库连接池使用率   | >80%（P2）      | 防止数据库连接耗尽      |


**告警流程**：
1. 指标超过阈值 → Prometheus触发告警 → Alertmanager转发告警 → 钉钉/邮件通知开发人员。
2. 开发人员收到告警后，通过SkyWalking查看链路追踪，ELK分析日志，定位问题根源。
3. 问题解决后，关闭告警，复盘优化（如调整阈值、优化代码）。

### 五、延伸场景题（高级）
#### 1. 多规格商品（如手机的颜色、内存组合）的库存扣减如何设计？是按「商品ID+规格ID」分库存表，还是在同一张表中用字段区分？
**推荐方案**：在同一张库存表中用「商品ID+规格ID」作为联合唯一索引，而非分表。

**设计方案**：
1. 库存表设计：
```sql
CREATE TABLE `product_sku_stock` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `product_id` bigint NOT NULL COMMENT '商品ID（如手机ID）',
  `sku_id` bigint NOT NULL COMMENT '规格ID（如黑色+128G）',
  `available_stock` int NOT NULL COMMENT '可用库存',
  `locked_stock` int NOT NULL DEFAULT 0 COMMENT '锁定库存',
  `version` int NOT NULL DEFAULT 0 COMMENT '乐观锁版本号',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_product_sku` (`product_id`, `sku_id`) COMMENT '商品+规格联合唯一索引',
  KEY `idx_sku_id` (`sku_id`) COMMENT '规格ID索引，提升查询性能'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品规格库存表';
```
2. 核心逻辑：
   - 每个规格对应一条库存记录，扣减时按「sku_id」加分布式锁，执行原子更新。
   - 商品总库存可通过`SUM(available_stock) WHERE product_id = #{productId}`计算（适合低频率查询，高频率查询可缓存总库存）。

**方案优势**：
- 无需分表，维护成本低（分表需处理跨表查询、扩容等问题）。
- 联合索引确保规格库存唯一性，避免重复扣减。
- 支持按商品ID或sku_id查询，灵活性高。

**注意事项**：
- 高并发场景下，总库存查询需缓存，避免频繁聚合计算。
- 规格ID需全局唯一，避免不同商品的规格ID冲突。

#### 2. 跨仓库库存扣减（如用户下单后从最近仓库发货），如何保证库存一致性和发货效率？
**核心设计思路**：按仓库+商品规格分库存，结合地理位置排序选择最优仓库，通过分布式锁保证跨仓库一致性。

**方案实现**：
1. 库存表设计（增加仓库维度）：
```sql
CREATE TABLE `warehouse_sku_stock` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `warehouse_id` bigint NOT NULL COMMENT '仓库ID',
  `product_id` bigint NOT NULL COMMENT '商品ID',
  `sku_id` bigint NOT NULL COMMENT '规格ID',
  `available_stock` int NOT NULL COMMENT '可用库存',
  `locked_stock` int NOT NULL DEFAULT 0 COMMENT '锁定库存',
  `province` varchar(32) NOT NULL COMMENT '仓库所在省份',
  `city` varchar(32) NOT NULL COMMENT '仓库所在城市',
  `version` int NOT NULL DEFAULT 0 COMMENT '乐观锁版本号',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_warehouse_sku` (`warehouse_id`, `sku_id`) COMMENT '仓库+规格联合唯一索引',
  KEY `idx_sku_province` (`sku_id`, `province`) COMMENT '规格+省份索引，提升查询效率'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='仓库-规格库存表';
```
2. 核心流程：
   -  用户下单时，获取用户所在省份/城市 → 按「sku_id+省份」查询有库存的仓库，按距离排序（如优先同城仓库）。
   -  对排序后的仓库依次尝试扣减库存（按「lock:warehouse_sku:${warehouseId}:${skuId}」加分布式锁），扣减成功则返回，失败则尝试下一个仓库。
   -  若所有仓库库存不足，返回「库存不足」。
3. 一致性保障：
   -  跨仓库扣减时，每个仓库的库存扣减通过分布式锁和原子更新保证一致性。
   -  订单取消时，释放对应仓库的锁定库存。

**发货效率优化**：
-  仓库地理位置缓存：将仓库的省份、城市、经纬度缓存到Redis，避免频繁查询数据库。
-  预分配仓库：热点商品提前分配到多个仓库，避免单一仓库库存耗尽。
-  异步发货：库存扣减成功后，通过消息队列触发发货流程，提升用户体验。

#### 3. 库存扣减时需要考虑「库存预警」（如库存低于阈值时自动补货），如何设计异步预警机制，避免影响扣减性能？
**异步预警机制设计**：
1. 核心原则：预警逻辑与库存扣减逻辑解耦，通过异步方式执行，避免同步预警导致扣减响应变慢。
2. 实现方案：
   -  步骤1：库存表增加「预警阈值」字段（`warning_threshold`），如设置为100（库存低于100时触发预警）。
   -  步骤2：库存扣减成功后，判断当前可用库存是否低于预警阈值，若是则发送「库存预警消息」到RocketMQ（Topic：`stock-warning-topic`），无需等待消息发送结果（异步非阻塞）。
   -  步骤3：部署专门的预警服务，消费「库存预警消息」，执行补货逻辑（如通知采购系统、自动生成补货单）。
   -  步骤4：预警服务记录补货日志，若补货失败则发送告警通知（如钉钉通知采购人员）。
3. 关键优化：
   -  消息去重：同一商品短时间内多次触发预警（如库存从101扣减到99，再扣减到98），避免重复发送消息，可通过Redis记录预警状态（如`warning:${skuId}`，设置5分钟过期）。
   -  批量预警：若多个商品同时触发预警，可批量发送消息（如每1分钟批量处理一次），减少消息队列压力。
   -  阈值动态调整：支持通过后台管理系统动态修改`warning_threshold`，无需重启服务。

**代码示例**：
```java
// 库存扣减成功后，异步触发预警
if (currentAvailableStock < stock.getWarningThreshold()) {
    // 异步发送消息，不阻塞当前流程
    CompletableFuture.runAsync(() -> {
        try {
            // Redis去重，避免重复预警
            String warningKey = "warning:sku:" + skuId;
            Boolean isWarning = stringRedisTemplate.opsForValue().setIfAbsent(warningKey, "1", 5, TimeUnit.MINUTES);
            if (Boolean.TRUE.equals(isWarning)) {
                StockWarningMessage message = new StockWarningMessage(skuId, currentAvailableStock, stock.getWarningThreshold());
                rocketMQTemplate.send("stock-warning-topic", MessageBuilder.withPayload(message).build());
            }
        } catch (Exception e) {
            log.error("发送库存预警消息失败，skuId:{}", skuId, e);
        }
    }, executorService);
}
```

#### 4. 基于Sharding-JDBC分库分表的场景下，库存表按商品ID分片后，分布式锁如何设计才能避免跨分片的并发问题？
**核心问题**：库存表按商品ID哈希分片后，同一商品的库存数据只存储在一个分片（库+表）中，跨分片的商品库存扣减无并发问题，但同一分片内的商品仍需分布式锁保证并发安全，同时需避免锁与分片的绑定导致的问题。

**分布式锁设计方案**：
1. 锁Key设计：按「分片键+商品ID」设计锁Key，确保同一商品的锁唯一，与分片无关。
   - 锁Key格式：`lock:stock:${productId}`（而非`lock:stock:${shardId}:${productId}`）。
   - 核心逻辑：无论商品数据存储在哪个分片，分布式锁的Key仅与商品ID相关，确保跨节点的同一商品扣减互斥。
2. 分布式锁实现：
   - 采用Redis Cluster分布式锁（Redisson），确保锁服务的高可用性，与分库分表的分片策略解耦。
   - 开启看门狗机制，避免锁超时释放，确保业务执行期间锁有效。
3. 跨分片库存操作处理（如合并库存、批量扣减）：
   - 若需跨分片执行库存操作（如查询所有分片的总库存），无需加全局锁，通过「分片并行查询+本地汇总」实现，避免性能瓶颈。
   - 若需跨分片批量扣减（如同一订单包含多个分片的商品），对每个商品单独加锁，分别执行扣减，避免全局锁导致的并发问题。

**方案优势**：
- 锁Key与分片无关，无需感知分库分表策略，简化逻辑。
- Redis Cluster分布式锁性能高，支持高并发场景。
- 细粒度锁（按商品ID），避免跨分片的锁竞争。

**注意事项**：
- 确保分布式锁的Redis集群与分库分表的数据库集群独立部署，避免相互影响。
- 跨分片批量扣减时，需处理部分商品扣减成功、部分失败的情况（如通过事务补偿、消息队列回滚）。

**告警流程**：
1. 指标超过阈值 → Prometheus触发告警 → Alertmanager转发告警 → 钉钉/邮件通知开发人员。
2. 开发人员收到告警后，通过SkyWalking查看链路追踪，ELK分析日志，定位问题根源。
3. 问题解决后，关闭告警，复盘优化（如调整阈值、优化代码）。

### 五、延伸场景题（高级）
#### 1. 多规格商品（如手机的颜色、内存组合）的库存扣减如何设计？是按「商品ID+规格ID」分库存表，还是在同一张表中用字段区分？
**推荐方案**：在同一张库存表中用「商品ID+规格ID」作为联合唯一索引，而非分表。

**设计方案**：
1. 库存表设计：
```sql
CREATE TABLE `product_sku_stock` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `product_id` bigint NOT NULL COMMENT '商品ID（如手机ID）',
  `sku_id` bigint NOT NULL COMMENT '规格ID（如黑色+128G）',
  `available_stock` int NOT NULL COMMENT '可用库存',
  `locked_stock` int NOT NULL DEFAULT 0 COMMENT '锁定库存',
  `version` int NOT NULL DEFAULT 0 COMMENT '乐观锁版本号',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_product_sku` (`product_id`, `sku_id`) COMMENT '商品+规格联合唯一索引',
  KEY `idx_sku_id` (`sku_id`) COMMENT '规格ID索引，提升查询性能'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品规格库存表';
```
2. 核心逻辑：
   - 每个规格对应一条库存记录，扣减时按「sku_id」加分布式锁，执行原子更新。
   - 商品总库存可通过`SUM(available_stock) WHERE product_id = #{productId}`计算（适合低频率查询，高频率查询可缓存总库存）。

**方案优势**：
- 无需分表，维护成本低（分表需处理跨表查询、扩容等问题）。
- 联合索引确保规格库存唯一性，避免重复扣减。
- 支持按商品ID或sku_id查询，灵活性高。

**注意事项**：
- 高并发场景下，总库存查询需缓存，避免频繁聚合计算。
- 规格ID需全局唯一，避免不同商品的规格ID冲突。

#### 2. 跨仓库库存扣减（如用户下单后从最近仓库发货），如何保证库存一致性和发货效率？
**核心设计思路**：按仓库+商品规格分库存，结合地理位置排序选择最优仓库，通过分布式锁保证跨仓库一致性。

**方案实现**：
1. 库存表设计（增加仓库维度）：
```sql
CREATE TABLE `warehouse_sku_stock` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `warehouse_id` bigint NOT NULL COMMENT '仓库ID',
  `product_id` bigint NOT NULL COMMENT '商品ID',
  `sku_id` bigint NOT NULL COMMENT '规格ID',
  `available_stock` int NOT NULL COMMENT '可用库存',
  `locked_stock` int NOT NULL DEFAULT 0 COMMENT '锁定库存',
  `province` varchar(32) NOT NULL COMMENT '仓库所在省份',
  `city` varchar(32) NOT NULL COMMENT '仓库所在城市',
  `version` int NOT NULL DEFAULT 0 COMMENT '乐观锁版本号',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_warehouse_sku` (`warehouse_id`, `sku_id`) COMMENT '仓库+规格联合唯一索引',
  KEY `idx_sku_province` (`sku_id`, `province`) COMMENT '规格+省份索引，提升查询效率'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='仓库-规格库存表';
```
2. 核心流程：
   -  用户下单时，获取用户所在省份/城市 → 按「sku_id+省份」查询有库存的仓库，按距离排序（如优先同城仓库）。
   -  对排序后的仓库依次尝试扣减库存（按「lock:warehouse_sku:${warehouseId}:${skuId}」加分布式锁），扣减成功则返回，失败则尝试下一个仓库。
   -  若所有仓库库存不足，返回「库存不足」。
3. 一致性保障：
   -  跨仓库扣减时，每个仓库的库存扣减通过分布式锁和原子更新保证一致性。
   -  订单取消时，释放对应仓库的锁定库存。

**发货效率优化**：
-  仓库地理位置缓存：将仓库的省份、城市、经纬度缓存到Redis，避免频繁查询数据库。
-  预分配仓库：热点商品提前分配到多个仓库，避免单一仓库库存耗尽。
-  异步发货：库存扣减成功后，通过消息队列触发发货流程，提升用户体验。

#### 3. 库存扣减时需要考虑「库存预警」（如库存低于阈值时自动补货），如何设计异步预警机制，避免影响扣减性能？
**异步预警机制设计**：
1. 核心原则：预警逻辑与库存扣减逻辑解耦，通过异步方式执行，避免同步预警导致扣减响应变慢。
2. 实现方案：
   -  步骤1：库存表增加「预警阈值」字段（`warning_threshold`），如设置为100（库存低于100时触发预警）。
   -  步骤2：库存扣减成功后，判断当前可用库存是否低于预警阈值，若是则发送「库存预警消息」到RocketMQ（Topic：`stock-warning-topic`），无需等待消息发送结果（异步非阻塞）。
   -  步骤3：部署专门的预警服务，消费「库存预警消息」，执行补货逻辑（如通知采购系统、自动生成补货单）。
   -  步骤4：预警服务记录补货日志，若补货失败则发送告警通知（如钉钉通知采购人员）。
3. 关键优化：
   -  消息去重：同一商品短时间内多次触发预警（如库存从101扣减到99，再扣减到98），避免重复发送消息，可通过Redis记录预警状态（如`warning:${skuId}`，设置5分钟过期）。
   -  批量预警：若多个商品同时触发预警，可批量发送消息（如每1分钟批量处理一次），减少消息队列压力。
   -  阈值动态调整：支持通过后台管理系统动态修改`warning_threshold`，无需重启服务。

**代码示例**：
```java
// 库存扣减成功后，异步触发预警
if (currentAvailableStock < stock.getWarningThreshold()) {
    // 异步发送消息，不阻塞当前流程
    CompletableFuture.runAsync(() -> {
        try {
            // Redis去重，避免重复预警
            String warningKey = "warning:sku:" + skuId;
            Boolean isWarning = stringRedisTemplate.opsForValue().setIfAbsent(warningKey, "1", 5, TimeUnit.MINUTES);
            if (Boolean.TRUE.equals(isWarning)) {
                StockWarningMessage message = new StockWarningMessage(skuId, currentAvailableStock, stock.getWarningThreshold());
                rocketMQTemplate.send("stock-warning-topic", MessageBuilder.withPayload(message).build());
            }
        } catch (Exception e) {
            log.error("发送库存预警消息失败，skuId:{}", skuId, e);
        }
    }, executorService);
}
```

#### 4. 基于Sharding-JDBC分库分表的场景下，库存表按商品ID分片后，分布式锁如何设计才能避免跨分片的并发问题？
**核心问题**：库存表按商品ID哈希分片后，同一商品的库存数据只存储在一个分片（库+表）中，跨分片的商品库存扣减无并发问题，但同一分片内的商品仍需分布式锁保证并发安全，同时需避免锁与分片的绑定导致的问题。

**分布式锁设计方案**：
1. 锁Key设计：按「分片键+商品ID」设计锁Key，确保同一商品的锁唯一，与分片无关。
   - 锁Key格式：`lock:stock:${productId}`（而非`lock:stock:${shardId}:${productId}`）。
   - 核心逻辑：无论商品数据存储在哪个分片，分布式锁的Key仅与商品ID相关，确保跨节点的同一商品扣减互斥。
2. 分布式锁实现：
   - 采用Redis Cluster分布式锁（Redisson），确保锁服务的高可用性，与分库分表的分片策略解耦。
   - 开启看门狗机制，避免锁超时释放，确保业务执行期间锁有效。
3. 跨分片库存操作处理（如合并库存、批量扣减）：
   - 若需跨分片执行库存操作（如查询所有分片的总库存），无需加全局锁，通过「分片并行查询+本地汇总」实现，避免性能瓶颈。
   - 若需跨分片批量扣减（如同一订单包含多个分片的商品），对每个商品单独加锁，分别执行扣减，避免全局锁导致的并发问题。

**方案优势**：
- 锁Key与分片无关，无需感知分库分表策略，简化逻辑。
- Redis Cluster分布式锁性能高，支持高并发场景。
- 细粒度锁（按商品ID），避免跨分片的锁竞争。

**注意事项**：
- 确保分布式锁的Redis集群与分库分表的数据库集群独立部署，避免相互影响。
- 跨分片批量扣减时，需处理部分商品扣减成功、部分失败的情况（如通过事务补偿、消息队列回滚）。